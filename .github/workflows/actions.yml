name: 'Terraform'

on: [push, pull_request]

env:
  DOCKER_REPOSITORY: bashox
  FRONTEND_IMAGE_NAME: revolgy-frontend
  BACKEND_IMAGE_NAME: revolgy-backend
  IMAGE_TAG: ${{ github.run_number }}
  CLUSTER_NAME: eks
  MIGRATIONS_IMAGE_NAME: revolgy-migrations


jobs:
  
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash
    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v3

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION}}

    # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      id: init
      run: |
        terraform -chdir=./production init
        terraform -chdir=./staging init


    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format
      id: format
      run: |
        terraform -chdir=./production fmt -check 
        terraform -chdir=./staging fmt -check 

    # validating the terraform code for any syntax error
    - name: Terraform validate
      id: validate
      run: |
          terraform -chdir=./production validate 
          terraform -chdir=./staging validate


    # Generates an execution plan for Terraform
    - name: Terraform Plan
      id: plan
      run: terraform -chdir=./production plan -no-color 

    - name: Terraform Plan Status
      if: steps.plan.outcome == 'failure'
      run: exit 1



      
    # Add a comment to pull requests with results
    - name: add-results-comment
      id: comment
      uses: actions/github-script@v6
      if: github.event_name == 'pull_request'
      env:
        PLAN: "terraform\n${{ steps.plan.outputs.stdout }}"
      

      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const output = `#### Terraform Initialization ‚öôÔ∏è\`${{ steps.init.outcome }}\`
          #### Terraform Format  üñå\`${{ steps.format.outcome }}\`
          #### Terraform Validation ü§ñ\`${{ steps.validate.outcome }}\`
          #### Terraform Plan üìñ\`${{ steps.plan.outcome }}\`
      
          <details><summary>Show Plan Changes</summary>
          
          \`\`\`\n
          ${process.env.PLAN}
          \`\`\`
          
          </details>

      
          
          *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Working Directory: \`${{ env.tf_actions_working_dir }}\`, Workflow: \`${{ github.workflow }}\`*`;
            
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          })

      # On push to main, build or change infrastructure according to Terraform configuration files
      # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks

  terratest:
    name: 'Terratest'
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    needs: [terraform]

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash
    
    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v3

     # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
        terraform_wrapper: false ## setting it false because it gives terratest assertion, problem
  

    - name: Terraform terratest
      uses: actions/setup-go@v3
      
  # testing the infrastructure incase of any change
    - name: Infra Testing
      id: terratest 
      run: |
        go mod init github.com/Bash-mocart/terratest
        go mod tidy -go=1.16 && go mod tidy -go=1.17
        go test -v -timeout 3000m

# lintng, testing and building
  lint-test-build:
    name: 'Lint. Test, Build'
    runs-on: ubuntu-latest
    if: github.event_name == 'push'


    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash
    
    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v3

    - name: setting up node
      uses: actions/setup-node@v3
      with:
        node-version: 13.8.0
        

    - name: linting backend
      working-directory: ./backend
      run: |
          npm install
          npm run lint

    - name: linting frontend
      working-directory: ./frontend
      run: |
          npm install  
          npm run lint

    
    - name: testing backend
      working-directory: ./backend
      run: |
          npm run test
        
    
    - name: testing frontend
      working-directory: ./frontend
      run: |
          npm run test

    - name: formatting frontend
      working-directory: ./frontend
      run: |
          npm run format
    
  
    - name: format backend
      working-directory: ./backend
      run: |
          npm run format
    
    # setting up for virtualization
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v2
    
    # setting up docker
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    # login to dockerhub
    - name: Login to DockerHub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
    
    # building docker container frontend
    - name: Build Docker Image frontend
      working-directory: ./frontend
      run:
        docker build --tag ${{ env.DOCKER_REPOSITORY }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }} --no-cache .
     
     # building docker container backend 
    - name: Build Docker Image migrations
      working-directory: ./backend
      run:
        docker build --tag ${{ env.DOCKER_REPOSITORY }}/${{ env.MIGRATIONS_IMAGE_NAME }}:${{ env.IMAGE_TAG }} -f Dockerfile_migrations --no-cache .
      
     # building docker container backend 
    - name: Build Docker Image backend
      working-directory: ./backend
      run:
        docker build --tag ${{ env.DOCKER_REPOSITORY }}/${{ env.BACKEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }} --no-cache .
  
  # scanning docker container 
    - name: Run Trivy vulnerability scanner frontend
      uses: aquasecurity/trivy-action@master
      continue-on-error: true # should be false in a real prod environment for the pipeline to fail and alert developers team of any security issue
      with:
        image-ref: 'docker.io/${{ env.DOCKER_REPOSITORY }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }}'
        format: 'table'
        exit-code: '1'
        ignore-unfixed: true
        vuln-type: 'os'
        severity: 'MEDIUM,HIGH,CRITICAL'

  # scanning docker container 
    - name: Run Trivy vulnerability scanner backend
      uses: aquasecurity/trivy-action@master
      continue-on-error: true # should be false in a real prod environment for the pipeline to fail and alert developers team of any security issue
      with:
        image-ref: 'docker.io/${{ env.DOCKER_REPOSITORY }}/${{ env.BACKEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }}'
        format: 'table'
        exit-code: '1'
        ignore-unfixed: true
        vuln-type: 'os'
        severity: 'MEDIUM,HIGH,CRITICAL'
    
    - name: Push Image to Docker Hub
      run: |
        docker push ${{ env.DOCKER_REPOSITORY }}/${{ env.BACKEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }}
        docker push ${{ env.DOCKER_REPOSITORY }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }}
  
#deploying to staging for the qa team

  deploy-staging:
    name: 'deploy-staging'
    needs: [lint-test-build]
    uses: Bash-mocart/workflow/.github/workflows/deploy.yml@main #uses a resuable job at https://https://raw.githubusercontent.com/Bash-mocart/workflow/main/.github/workflows/deploy.yml
    with: 
      environment: staging
      env_dir: ./staging 
      helm_dir: ./helm
      IMAGE_TAG: '${{ github.run_number }}'
      CLUSTER_NAME: '${{ env.CLUSTER_NAME }}'
      DOCKER_REPOSITORY: '${{ env.DOCKER_REPOSITORY }}'
      FRONTEND_IMAGE_NAME: '${{ env.FRONTEND_IMAGE_NAME }}'
      BACKEND_IMAGE_NAME: '${{ env.BACKEND_IMAGE_NAME }}'
      MIGRATIONS_IMAGE_NAME: '${{ env.MIGRATIONS_IMAGE_NAME }}'
    secrets:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION}}
      TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
      ACCOUNT_ID: ${{ secrets.ACCOUNT_ID }}
      GRAFANA_PASS: ${{ secrets.GRAFANA_PASS }}
      TYPEORM_CONNECTION: ${{ secrets.TYPEORM_CONNECTION }}
      TYPEORM_MIGRATIONS_DIR: ${{ secrets.TYPEORM_MIGRATIONS_DIR }}
      TYPEORM_MIGRATIONS: ${{ secrets.TYPEORM_MIGRATIONS }}
      TYPEORM_PORT: ${{ secrets.TYPEORM_PORT }}
      TYPEORM_PASSWORD: ${{ secrets.TYPEORM_PASSWORD }}
      TYPEORM_USERNAME: ${{ secrets.TYPEORM_USERNAME }}
      TYPEORM_DATABASE: ${{ secrets.TYPEORM_DATABASE }} 
      TYPEORM_MIGRATIONS_DIR_P: ${{  secrets.TYPEORM_MIGRATIONS_DIR_P }}
      TYPEORM_MIGRATIONS_P: ${{ secrets.TYPEORM_MIGRATIONS_P }}
      TYPEORM_MIGRATIONS_ENTITIES_P: ${{ secrets.TYPEORM_MIGRATIONS_ENTITIES_P }}



#deploying to production after merging to master branch and when all checks have succeed
  deploy-prod:
    name: 'deploy-prod'
    needs: [deploy-staging]
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'

    uses: Bash-mocart/workflow/.github/workflows/deploy.yml@main
    with:  
      environment: production
      env_dir: ./production
      helm_dir: helm
      IMAGE_TAG: ${{ github.run_number }}
      CLUSTER_NAME: ${{ env.CLUSTER_NAME }}
      DOCKER_REPOSITORY: ${{ env.DOCKER_REPOSITORY }}
      FRONTEND_IMAGE_NAME: ${{ env.FRONTEND_IMAGE_NAME }}
      BACKEND_IMAGE_NAME: ${{ env.BACKEND_IMAGE_NAME }}
      MIGRATIONS_IMAGE_NAME: ${{ env.MIGRATIONS_IMAGE_NAME }}
    secrets:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION}}
      TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
      ACCOUNT_ID: ${{ secrets.ACCOUNT_ID }}
      GRAFANA_PASS: ${{ secrets.GRAFANA_PASS }}
      TYPEORM_CONNECTION: ${{ secrets.TYPEORM_CONNECTION }}
      TYPEORM_MIGRATIONS_DIR: ${{ secrets.TYPEORM_MIGRATIONS_DIR }}
      TYPEORM_MIGRATIONS: ${{ secrets.TYPEORM_MIGRATIONS }}
      TYPEORM_PORT: ${{ secrets.TYPEORM_PORT }}
      TYPEORM_PASSWORD: ${{ secrets.TYPEORM_PASSWORD }}
      TYPEORM_USERNAME: ${{ secrets.TYPEORM_USERNAME }}
      TYPEORM_DATABASE: ${{ secrets.TYPEORM_DATABASE }}
      TYPEORM_MIGRATIONS_DIR_P: ${{  secrets.TYPEORM_MIGRATIONS_DIR_P }}
      TYPEORM_MIGRATIONS_P: ${{ secrets.TYPEORM_MIGRATIONS_P }}
      TYPEORM_MIGRATIONS_ENTITIES_P: ${{ secrets.TYPEORM_MIGRATIONS_ENTITIES_P }}
